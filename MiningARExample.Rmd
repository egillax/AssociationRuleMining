---
title: "Mining Associations Rules - Example 1"
author: "Solon Ioannou"
date: "11/5/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(results = 'hide')
library(DatabaseConnector)
library(SqlRender)
library(Eunomia)
library(FeatureExtraction)
library(knitr)
library(kableExtra)
```

### Connect to the database 

```{r}
### Define database parameters
cdmdatabaseschema = "main"
resultsdatabaseschema = "main"

connectionDetails <- Eunomia::getEunomiaConnectionDetails()
connection <- connect(connectionDetails)
#on.exit(DatabaseConnector::disconnect(connection)) #Close db connection on error or exit

```

#### Define cohort ####

There are two options for defining a cohort:
- 1) Define the cohort in ATLAS and export the SQL file
- 2) define it locally within R

```{r}
cohort <- readSql("data/cohorts/Eunomia_MI_cohort.sql")

renderTranslateExecuteSql(connection, cohort, cdm = "main")

sql <- "ALTER TABLE #diagnoses ADD cohort_definition_id INT NOT NULL DEFAULT(1)"

# Execute the script to receive the data
renderTranslateExecuteSql(connection, sql)

querySql(connection, "SELECT count(*) FROM diagnoses;")
```

### Get the data and close the connection

```{r}
#### Feature Extraction ####
covariateSettings <- createCovariateSettings(useConditionOccurrenceAnyTimePrior = TRUE, 
                                             #includedCovariateIds = c(), 
                                             #includedCovariateConceptIds = c()
                                             )


covariateData_eunomia <- getDbCovariateData(connection = connection, cdmDatabaseSchema = cdmdatabaseschema, cohortDatabaseSchema = resultsDatabaseSchema, cohortTable = "diagnoses", rowIdField = "subject_id", covariateSettings = covariateSettings, cohortTableIsTemp = TRUE)


disconnect(connection)
```

# Association Mining

## Prepare the data

```{r}
df_eunomia <- as.data.frame(covariateData_eunomia$covariates) #Assign covariates in a dataframe
```


```{r, include=FALSE}
# For the function getNamesFromCovariateId remember to add an argument for filename. This filename is the same required for the function getInputDataForAssociationRules2 bellow, which the function called right after. Therefore consider placing these two functions in one.

getNamesFromCovariateId <- function(data, covariateDataObject, fileToSave){
  dataframe=data
  cDO = covariateDataObject
  names.df <- as.data.frame(cDO$covariateRef)
  names.df$covariateId <- as.character(names.df$covariateId)
  names.df$covariateLabel <-  stringr::str_replace(names.df$covariateName, ".*: ", "")
  names.df$covariateLabel2 <- stringr::str_replace_all(names.df$covariateLabel, " ", "_")
  names.df <-names.df %>% 
    arrange(conceptId) %>%
    mutate(SPMFinputId = match(covariateLabel, unique(covariateLabel)), 
           SPMFnameID = paste("@ITEM", SPMFinputId, covariateLabel2, sep = "="))
  write.table(x = "@CONVERTED_FROM_TEXT", paste(fileToSave), quote = FALSE, row.names = FALSE, col.names = FALSE)
  write.table(names.df$SPMFnameID, paste(fileToSave), quote = FALSE, row.names = FALSE, col.names = FALSE, append = TRUE)
  dataframe$covariateId <- as.character(dataframe$covariateId)
  df_input <- dplyr::inner_join(dataframe, names.df, by = "covariateId")
  # Filtering useful variables
#  df_input2 <- dplyr::select(df_input, c(rowId, eventId, SIZE, covariateLabel))
#  return(df_input2)
  return(df_input)
}

getInputDataForAssociationRules2 <- function(data, filename){
  if(filename == ""){
    stop("Must declare a filename")
  } 
  
  if(grepl("\\.txt$", filename)== FALSE){
    stop("Filename should be a .txt file")
  }
  
  x <- data %>%
    dplyr::arrange(rowId, SPMFinputId) %>%
    dplyr::group_by(rowId) %>%
    dplyr::summarise(conditionbySPMFinputId = paste0(SPMFinputId, collapse = " ")) %>% 
    dplyr::select(conditionbySPMFinputId) %>%
    write.table(., file = paste(filename), col.names = FALSE, quote = FALSE, row.names = FALSE, append = TRUE)

  message(paste("Input data has been created succesfully and saved in", filename))
}


getAssociationSets <- function(algorithm, inputFile, outputFile, minsup, showID = FALSE) {
  
  associationAlgorithms <- c("Apriori", "Eclat", "FP-Growth", "Relim")
  `%notin%` <- Negate(`%in%`)
  outputID = paste(tolower(showID))
  #maxLengthvalue = jdx::convertToJava(maxLength, scalars.as.objects = TRUE)
  #maxGapvalue = jdx::convertToJava(maxGap, scalars.as.objects = TRUE)
  maxLengthvalue = 1000
  maxGapvalue = 1000
  
  if(algorithm %notin% associationAlgorithms){
    stop("Algorithm is not supported at the moment!")
  }
  message("Running algorithm")
  
  #Below I replaced the Inf values for maxLength and maxGap with 1000 since Inf is not a Java object for SPAM and prefixSpan
  if (algorithm == "Apriori" ) {
    executable <- paste("java -jar ./inst/java/spmf.jar run", algorithm, inputFile, outputFile, minsup) # Removed outputID but should look up for other parameters since some are applicable
  } else {
    if (algorithm == "Eclat") {
      executable <- paste("java -jar ./inst/java/spmf.jar run", algorithm, inputFile, outputFile, minsup)
    } else {
      if (algorithm == "FP-Growth"){
        executable <- paste("java -jar ./inst/java/spmf.jar run", "FPGrowth", inputFile, outputFile, minsup)
      } else {
       if (algorithm == "Relim"){
         executable <- paste("java -jar ./inst/java/spmf.jar run", "Relim", inputFile, outputFile, misup)
       } 
      } 
    }
  }
  message(paste("The command line that has been running is:", print(executable)))
  system(executable)
}

getOutputFromAssociationRules <- function(inputFile, ) {
  inputfile = read.delim(inputFile, header = FALSE)
  x <- inputfile %>%
    mutate(Count = stringr::str_replace_all(V1, ".*: ", ""),
           Set = stringr::str_replace_all(V1, ".#.*", ""))
  
  x$Set <- stringr::str_replace_all(x$Set, " ", ", ") 
  x$Set <- stringr::str_replace_all(x$Set, "_", " ") 
  x$Set <- stringr::str_replace_all(x$Set, ", $", "")
  x <- dplyr::select(x, c(Set, Count))
  return(x)
}

getARMdata <- function(data){
  data = data
  x = as(split(data[,"covariateLabel"], data[,"rowId"]), "transactions")
  return(x)
}

```


```{r}
df_eunomia_2 <- getNamesFromCovariateId(df_eunomia, covariateData_eunomia)
# the following will tranform the dataset to the necessary input for the arules package
library(arules)
#getInputDataForAssociationRules <- function(data){
#x = as(split(data[,"covariateLabel"], data[,"rowId"]), "transactions")
#  return(x)  
#}
#df_eunomia_3 <- getInputDataForAssociationRules(df_eunomia_2)
#str(df_eunomia_3)

# we need to transform the dataset to the necessary input for the SPMF implementation
str(df_eunomia_2)

# By running the following function our dataset is prepared an save in a file
getInputDataForAssociationRules2(data = df_eunomia_2, filename = "data/processed/inputForSPMF/eunomia_MI.txt")

```

### Build algorithms

The function to run the available association rule algorithms is getAssociationSets(). 

```{r}
testtable <- readLines("data/processed/inputForSPMF/eunomia_MI.txt")


outputfile = "results/apriori_eunomia.txt"
getAssociationSets('Apriori', inputFile = "data/processed/inputForSPMF/eunomia_MI.txt", outputFile = "results/apriori_eunomia.txt", minsup = 0.5)
```

### Results

```{r}
results.df <- getOutputFromAssociationRules("results/apriori_eunomia.txt")

results.df <- results.df %>%
  mutate(Support = (as.numeric(Count)/67)) %>%
  arrange(desc(Support))

spmf_sets <- nrow(results.df)
```
  
`r kable(results.df) %>% scroll_box(width = "100%", height = "400px") %>% kable_paper("striped")`  
  
### For comparisson implementing apriori in arules

```{r, echo=FALSE}
df_eunomia_3 <- getARMdata(df_eunomia_2)
str(df_eunomia_3)

# Apriori set up
ap_params <- list(
  support = 0.5, 
 # confidence = , 
  minlen = 1,     #number of items per itemset
  maxlen = 1000,    #maximal number of items per itemset 
  arem = "chi2",  #additional rule evaluation
  aval = TRUE,    #return additional rule measure
  minval = 0,   #default value for minimal value of additional rule measure
  maxtime = 0     #Disabling the limit for subset checking
)
arules_ap <- apriori(data = df_eunomia_3, parameter = ap_params)
inspect(arules_ap)
subsetRules <- which(colSums(is.subset(arules_ap, arules_ap)) > 1) # get subset rules in vector
length(subsetRules)  #> 590
rules <- arules_ap[-subsetRules]
is.redundant(arules_ap)

rules2 <- unique(arules_ap)
inspect(rules2)

 gi <- generatingItemsets(arules_ap)
 d <- which(duplicated(gi))
rules3<- arules_ap[-d]
inspect(rules3)
 rule_itemsets <- generatingItemsets(rules3)
rule_itemsets@quality
inspect(rule_itemsets)

class(rule_itemsets)
labels(rule_itemsets)
str(rule_itemsets)
rule_itemsets@quality$support
rule3_df <- data.frame(ItemSets = labels(rule_itemsets), 
                       Support = rule_itemsets@quality$support)
rule3_df
rule3_df$ItemSets <- stringr::str_replace_all(rule3_df$ItemSets, pattern = "^\\{|\\}$", "")
rule3_df$ItemSets <- stringr::str_replace_all(rule3_df$ItemSets, ",", ", ")
#stringr::str_replace_all(rule3_df$ItemSets, "[["
 
length(setdiff(rule3_df$ItemSets, results.df$Set))
length(setdiff( results.df$Set, rule3_df$ItemSets))
identical(as.list(rule3_df$ItemSets), as.list(results.df$Set))
rule3_df <- arrange(rule3_df, Support)
results.df <- results.df %>%
  mutate(Support2 = as.numeric(Support) / 67) %>%
  arrange(Support2)
  
arules_rls <- as.list(rule3_df$ItemSets)
spmf_rls <- as.list(results.df$Set)

#setdiff(arules_rls, spmf_rls)
#SameElements <- function(a, b) return(identical(sort(a), sort(b)))
#lapply()
#lapply(spmf_rls, function(x) SameElements(x, arules_rls))
#lapply(spmf_rls, function(x) setdiff(x, arules_rls))

arules_df <- as(arules_ap, "data.frame")
arules_df <- arules_df %>% arrange(desc(support))
arules_sets <- nrow(arules_df)
```

`r kable(arules_df) %>% scroll_box(width = "100%", height = "400px") %>% kable_paper("striped")`

### Benchmarking  

`r kable(cbind(spmf_sets, arules_sets), col.names = c("SPMF", "Arules"), table.attr = "style='width:30%;'", align = "cc") %>% kable_styling()`

```{r}
#library(microbenchmark)
#mbm_ar <- microbenchmark("spmf" = { getAssociationSets('Apriori', inputFile = #"data/processed/inputForSPMF/eunomia_MI.txt", outputFile = "results/apriori_eunomia.txt", minsup = 0.5) }, 
#                      "arules" = { apriori(data = df_eunomia_3, parameter = ap_params) })
#
#mbm_ar
#library(ggplot2)
#plot_ar <- autoplot(mbm_ar)
#
#ggsave(plot = plot_ar, "plots/microbenchmark_AR_apriori.png" )
```

![Figure 1: Results of microbenchmarking between arules::apriori and SPMF::Apriori](plots/microbenchmark_AR_apriori.png)  




